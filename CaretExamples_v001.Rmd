---
title: "Caret Examples"
author: "davegoblue"
date: "April 14, 2016"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## Overall Objective  
This R Markdown is to document some key ideas I have seen about the "caret" library in a JHU Coursera module on Practical Machine Learning.  The basic syntax of caret ports across many different analysis techniques, and it seems extremely handy for many phases of analysis.  The document primarily captures the code used in the JHU module for my personal future reference, along with a mix of instructor thoughts and a few of my syntheses.
  
The broad themes of caret include:  
  
* Pre-processing data - preProcess()  
* Partitioning raw data in to test/train - createDataPartition(), createResample(), createTimeSlices()  
* Training models on the training data - train()  
* Applying a training model to an analogous dataset - predict()  
* Comparing predictions (often to reality) - confusionMatrix()  
  
## Caret Usage  
####_Basic Example_  
Below is a basic example for using caret to make and test a simple prediction.  The "spam" dataset from library "kernlab" is assessed through this simple example.  

First, the relevant libraries are loaded, with a data partition index creates and then applied to create testing and training data.  Note that -inTrain means exclude the indices contained by inTrain, so testing and training will be mutually exclusive in this case.  

```{r}
library(caret); 
library(kernlab); 
data(spam, package="kernlab") ## make sure to get the kernlab version rather than ElemStatLearn

## Use createDataPartition() to create an index with 75% of the row numbers
inTrain <- createDataPartition(y=spam$type, p=0.75, list=FALSE)
training <- spam[inTrain, ]
testing <- spam[-inTrain, ]
dim(training)

```

Next, we use caret to run GLM on the training data.  The training syntax almost always looks just like this, although with changes to the ~ formula and/or method statement.  Depending on the method (e.g., bootstrap or resample), there is sometimes an RNG component and thus merit to setting the seed.  Note that caret and all of its sub-components are frequently being updated (sometimes with impact on RNG), so there is no real guarantee of reproducibility once any component(s) of the version originally used has been sunsetted.  

```{r, cache=TRUE}

## Set cache=TRUE for faster re-runs
set.seed(32343)

## Runs the GLM and stores the outputs as modelFit
modelFit <- train(type ~ ., data=training, method="glm")

## Prints descriptors of modelFit
modelFit

## Prints coefficients that come back from the final GLM selected
modelFit$finalModel

## Applies modelFit (which was built from training) to make predictions on the testing data
predictions <- predict(modelFit, newdata=testing)

## Runs the confusion matrix and outputs some interesting statistics
confusionMatrix(predictions, testing$type)

```
  
There are frequently warnings thrown back by the caret library, though they often do not seem to impact the predictive ability.  The library is sometimes a bit of a black-box, and prediction is an area that often contains extreme trade-offs between parsimony, intepretability, scalability, predictive power, and the like.  It is wise to be sure the approach and final model align reasonably with how the specific end-user for the algorithm might prioritize these aims.  
  
####_Parallel Processing_  
Len Greski wrote an excellent article on using parallel processing for the train() function in caret.  This is particularly valuable for computationally intensive approaches as it increases R's ability to use my CPU from ~25% to ~75%.  See <https://github.com/lgreski/datasciencectacontent/blob/master/markdown/pml-randomForestPerformance.md>  

The below is cut/pasted from Len's blog so that I can easily access it even when I am offine.  As setup, Len uses the "sonar" data from the "mlbench" library.  See below:  
```{r}
library(mlbench)
data(Sonar)

inTraining <- createDataPartition(Sonar$Class, p = .75, list=FALSE)
training <- Sonar[inTraining,]
testing <- Sonar[-inTraining,]

# set up training run for x / y syntax because model format performs poorly
x <- training[,-61]
y <- training[,61]
```
  
Next, Len calls libraries for parallel processing and sets trainControl to allow for parallel processing.  
```{r}
library(parallel)
library(doParallel)

cluster <- makeCluster(detectCores() - 1) # convention to leave 1 core for OS
registerDoParallel(cluster)

fitControl <- trainControl(method = "cv", number = 10, allowParallel = TRUE)
```
  
Then, Len runs train() function, calling fitControl to make sure it runs in parallel:  
```{r, cache=TRUE}
## Set cache=TRUE so that re-runs go faster
fit <- train(x, y, method="rf", data=Sonar, trControl = fitControl)
```
  
Lastly, the cluster is explicitly shut down:  
```{r}
stopCluster(cluster)

## Seems to be needed, at least for my machine
registerDoSEQ() ## per http://stackoverflow.com/questions/25097729/un-register-a-doparallel-cluster
```
  
Len ran several experiments on a larger dataset and found that parallel processing on an HP Omen improved run time for a Random Forest called by train() from ~450 seconds to ~200 seconds.  This looks to be very handy.  
  

####_Data Slicing_  
Continuing with the spam dataset, we may want to slice it.  There are three common methods described below:  
  
* k-fold  
* resample  
* time slices  
  
```{r}

## ?createFolds will bring up the help menu for all types of data splitting

## Document the length of the spam dataset
length(spam$type)

## Create 10 folds (all independent)
set.seed(32323)
folds <- createFolds(y=spam$type, k=10, list=TRUE, returnTrain=FALSE)
sapply(folds, FUN=length)
sum(sapply(folds, FUN=length)) ## same length as original
myCheck <- NULL
for (intCtr in 1:10) { myCheck <- c(myCheck, folds[[intCtr]]) }
identical(1:length(spam$type), myCheck[order(myCheck)]) ## all elements used exactly once
folds[[1]][1:10]

## Create 10 resamples (data can be used multiple times)
set.seed(32323)
folds <- createResample(y=spam$type, times=10, list=TRUE)
sapply(folds, length) ## Each fold same length as original
myCheck <- NULL
for (intCtr in 1:10) { myCheck <- c(myCheck, folds[[intCtr]]) }
myCount <- NULL
for (intCtr in 1:length(spam$type)) { myCount <- c(myCount, sum(myCheck==intCtr)) }
plot(x=1:length(spam$type), y=myCount, col="red", pch=19) ## Indices used different # times

## Create test/train data for a time series (needs to be reasonably contiguous)
set.seed(32323)
tme <- 1:1000 ## For my series, I am interested in times 1-1000
folds <- createTimeSlices(y=tme, initialWindow=20, horizon=10) ## train on 20, test on 10
names(folds)
folds$train[[1]] ## First fold trains on 1-20
folds$test[[1]] ## First fold tests on 21-30
folds$train[[length(folds$train)]] ## Last fold trains on 971-990 (max is 1000 per tme)
folds$test[[length(folds$train)]] ## Last fold tests on 991-1000 (max is 1000 per tme)

```

Some of the algorithms in the caret library take care of these automatically.  However, it is nice to have the flexibility to create partitions in whatever manner is best suited for the task at hand.  
  
####_Training options_  
There are many options that can be used while training the data.  Typically, it is fine to just use the defaults, but some of the options include:  
```{r}

args(train.default)
## metric can be RMSE/RSquared for continuous and Accuracy/Kappa for categorical
## weights would be if you have (for example) and unbalanced training set

args(trainControl)

```
  
Some of the key options for trainControl can include:  
  
* method= (boot, boot632, cv, repeatedcv, LOOCV) for (boostrap, bootstrap with adjustment, cross-validate, repeatedly cross-validate, leave-one-out-cross-validation)  
* number= (for boot/cross-validation, number of samples to take)  
* repeats= (number of times to repeat sub-sampling; if big, this can slow things down)  
  
It is generally valuable to set a seed, either overall or for each resample (especially for parallel fits).  
  
####_Plotting predictors_  
Plotting the predictors can be a helpful component of exploratory data analysis prior to running prediction algorithms.  This example will focus on the "Wage" data from the ISLR library.  
  
```{r}

library(ISLR); library(ggplot2); library(caret)
data(Wage)
summary(Wage)

inTrain <- createDataPartition(y=Wage$wage, p=0.7, list=FALSE)
training <- Wage[inTrain, ]
testing <- Wage[-inTrain, ]
dim(training); dim(testing)

```

One option is to create a feature plot for a few key variables.  
```{r}
featurePlot(x=training[ , c("age", "education", "jobclass")], y=training$wage, plot="pairs")
```
  
Another option is to use ggplot2 for color and regression smoothning.  
```{r}
## Color by jobclass
qplot(age, wage, data=training, color=jobclass)

## Color by education and add a regression smooth
qq <- qplot(age, wage, data=training, color=education)
qq + geom_smooth(method="lm", formula=y~x)

```

Another option is to create factors and then use jitter to make the boxplot.  
```{r}

library(Hmisc)
cutWage <- cut2(training$wage, g=3)
table(cutWage)
p2 <- qplot(cutWage, age, data=training, fill=cutWage, geom=c("boxplot", "jitter"))
p2

t1 <- table(cutWage, training$jobclass)
t1
prop.table(t1, 1)

```
  
And yet another option is to look at the density plots.  
```{r}
qplot(wage, color=education, data=training, geom="density")
```

Some additional notes relevant to the prediction process include:  
  
1.  Only use the training data for plotting - no cheating with a peek at the test data!  
2.  Look for imbalances in outcomes/predictors, outliers, groups of "unexplained" points, skewed variables, etc.  
3.  Try to find the ggplot2 tutorial and the caret tutorial  
  
####_Pre-processing_  
Exploratory data analysis may reveal issues requiring data pre-processing.  This can be particularly the case with parametric approaches where skew, collinearity, missing neighbors (NA) and the like can cause problems.  
  
The spam dataset can again be analyzed for an example.  Note the extremely significant skew in the runs of capital letters (capitalAve).  
  
```{r}
library(caret); library(kernlab); data(spam)

inTrain <- createDataPartition(y=spam$type, p=0.75, list=FALSE)
training <- spam[inTrain, ]
testing <- spam[-inTrain, ]

hist(training$capitalAve, main="", xlab="Ave. capital run length")

mean(training$capitalAve) ; sd(training$capitalAve)

```

One option is to use base R to standardize each of the variables to N(0,1).  The mean and sd from the training set need to be applied to the test set data also, so that we stay uninformed as to the test set data. 

```{r}

## Calculate metrics from training set and apply to training set
trainCapAve <- training$capitalAve
trainCapAveS <- (trainCapAve - mean(trainCapAve)) / sd(trainCapAve)
mean(trainCapAveS) ; sd(trainCapAveS)

## Apply the same transformations to the testing set
testCapAve <- testing$capitalAve
testCapAveS <- (testCapAve - mean(trainCapAve)) / sd(trainCapAve)
mean(testCapAveS) ; sd(testCapAveS)

```

Alternately, the preProcess() command can be used to automatically take the same commands and apply them to the training and testing data.  
  
```{r}

## Set up a preProcess() command
preObj <- preProcess(training[,-58], method=c("center", "scale")) ## standardizes all variables

## Apply to training
trainCapAveS <- predict(preObj, training[,-58])$capitalAve
mean(trainCapAveS); sd(trainCapAveS)

## Apply to testing
testCapAveS <- predict(preObj, testing[,-58])$capitalAve
mean(testCapAveS); sd(testCapAveS)

```

The preProcess commands can also be passed to the train() commands.  
  
```{r, cache=TRUE}

## Set cache=TRUE to speed up re-runs
set.seed(32343)
modelFit <- train(type ~ ., data=training, preProcess=c("center", "scale"), method="glm")
print(modelFit)

```

The Box-Cox transform is available, though since it is continuous, it does not solve the "many zeroes" problem, as shown by the decidedly non-linear QQ plot.  
  
```{r}

preObj <- preProcess(training[,-58], method=c("BoxCox")) ## standardizes all variables with Box-Cox
trainCapAveS <- predict(preObj, training[,-58])$capitalAve
par(mfrow=c(1,2)) ; hist(trainCapAveS) ; qqnorm(trainCapAveS) ; par(mfrow=c(1,1))

```

Since many prediction algorithms do not work well with NA, the k-nearest-neighbors approach can be applied to impute those:  
  
```{r}

## Create some fake NA data
set.seed(13343)
training$capAve <- training$capitalAve
selectNA <- rbinom(dim(training)[1], size=1, prob=0.05)==1
training$capAve[selectNA] <- NA

## Impute using knn
preObj <- preProcess(training[,-58], method="knnImpute")
capAve <- predict(preObj, training[,-58])$capAve

```

The preProcess() command is especially useful since it can be repeatedly applied to data as needed - train, test, validate, etc.  
  
####_Covariate creation_  
Covariates (aka features or predictors) are the variables to be used in the model.  There are two levels:  
  
* Level 1 - from raw data to covariate (such as converting an e-mail to multiple descriptive statistics that could be used to predict whether it is spam)  
* Level 2 - transforming to create tidy covariates (such as squaring or taking a log or the like)  
  
Level 1 extractions tend to be domain specific, and the "science" (research) component is especially important during this phase.  Some guiding principles apply:  
  
* The balancing act is summarization vs. information loss  
* Examples include: 
  1.  Text Files: Frequency of words, frequency of phrases (google "ngrams"), proportion of capital letters, etc.  
  2.  Images: edges, corners, blobs, ridges ("computer vision feature detection")  
  3.  Webpages: Number/type of elements, colors, videos ("A/B testing")  
  4.  People: Height, weight, hair color, sex, country of origin  
* The more you know about the domain, the better job you will do  
* When in doubt, err on the side of more features  
* This phase can be automated, but be very careful!  There is high risk of over-fitting, finding features that work great on the training data and not at all on the testing data  
  
Level 2 conversions make tidy covariates (Level 1) in to transformed covariates (Level 2):  
  
* This is more often for some methods (regression, svm) than others (trees, forests)  
* Should only be run on the training data  
* Exploratory data analysis (plotting, tables, etc.) is the core component  
* New covariates should be added to data frames, and with recognizable names  
  
The wage data (ISLR) will again be used for an example:  
```{r}
library(ISLR) ; library(caret) ; data(Wage)
inTrain <- createDataPartition(y=Wage$wage, p=0.7, list=FALSE)
training <- Wage[inTrain, ]
testing <- Wage[-inTrain, ]

```
  
One common approach is to create indicator (dummy) variables:  
```{r}
table(training$jobclass)
dummies <- dummyVars(wage ~ jobclass, data=training) ## dummyVars is a caret function
head(predict(dummies, newdata=training)) ## using predict() on dummies creates the dummy variables

```
  
There is a function for identifying variables with near zero variance.  This is handy, as these will have no predictive power:  
```{r}
nsv <- nearZeroVar(training, saveMetrics=TRUE)
nsv
```
  
Additionally, splines can be created on the training data and then applied to the test data:  
```{r}
library(splines)
bsBasis <- bs(training$age, df=3) ## Creates a polynomial variable
head(bsBasis) ## column 1 is age, column 2 is age^2, column 3 is age^3

## Plot the results from the cubic spline
lm1 <- lm(wage ~ bsBasis, data=training)
plot(training$age, training$wage, pch=19, cex=0.75)
points(training$age, predict(lm1, newdata=training), col="red", cex=1.5, pch=19)

## Application of the spline to the test data
head(predict(bsBasis, age=testing$age)) ## need to use the exact same procedure

```

There is a guide on preprcessing with caret that may be valuable to look at.  Good science and domain knowledge are the keys - google "feature extraction for [good search term]" before starting in a new area.  And, leverage good exploratory analysis techniques (training set only) and then the preProcess() function in caret.  Be very careful not to overfit, and maintain a clean "test" data set to understand out of model error.  
  
####_Pre-processing with principal component analysis (PCA)_  
Principal Component Analysis (PCA) is a topic that I want to explore further.  This module provided a few basic pointers about the concept and its usage in R.  
  
The basic idea is that many of the predictor variables may be highly correlated.  It may be nice to include a summary subset that retains most of the information but little of the correlation.  Broadly, there are two goals:  
  
1.  Statistics - find a new set of variables that are uncorrelated but explain as much variance as possible  
2.  Compression - find the lowest-rank (fewest variables) matrix that explains the original data  
  
The "spam" dataset can again be analyzed to explore the concept:  
```{r}
library(caret); library(kernlab); data(spam, package="kernlab")

inTrain <- createDataPartition(y=spam$type, p=0.75, list=FALSE)
training <- spam[inTrain, ]
testing <- spam[-inTrain, ]

## Column 58 is the factor we want to predict; find all the other correlations
## Set the diagonals (variables with self, which will have r=1) all to 0
## Flag everything else with an 80%+ magnitude of correlation
M <- abs(cor(training[ , -58]))
diag(M) <- 0 ## takes care of the correlation with self issue
which(M > 0.8, arr.ind=TRUE)

## Identify the culprits, and plot them
names(spam)[c(32, 34, 40)]
plot(spam[,34], spam[, 32])
plot(spam[,40], spam[, 32])

```
  
The basic idea behind PCA is that we might not need (or even want) every predictor:  
  
1.  Weighted combinations of predictors may work better  
2.  Combinations should be chosen to retain as much information (explain as much variance) as possible  
3.  Benefits include both a smaller dataset (fewer predictors) and reduced noise (benefit of averaging)  
  
One potential idea is to "rotate"" the data - see below for an example:  
```{r}

## Recall that 0.71 is sqrt(2), so this essentially "preserves"" the length
X <- 0.71 * training$num415 + 0.71 * training$num857 ## captures almost all of the information
Y <- 0.71 * training$num415 - 0.71 * training$num857 ## captures almost none of the information
plot(X, Y)

```
  
The scaled solutions are SVD and PCA:  
  
* SVD - Suppose that X is a matrix with each variable in a column and each observation in a row, then SVD is a matrix decomposition such that X = U % * % D % * % t(V), where the columns of U are orthogonal (left singular vectors), the columns of V are orthogonal (right singular vectors), and D is diagnonal (singular values)  
* PCA - The principal components are equal to the right singular vectors (columns of V) if you first standardize (subtract mu, then divide by sigma) all of the variables  
  
A small example can again be drawn from the spam dataset:  
```{r}

## Create a small dataset and then use it
smallSpam <- spam[,c(34,32)]
prComp <- prcomp(smallSpam)
plot(prComp$x[,1], prComp$x[,2]) ## pretty much like what we saw with the 0.71 (sqrt(2)) transform above

## See which rotations have been performed
## PC1 explains the most variation, PC2 explains the second most variation, etc.
prComp$rotation

```
  
The example can be extended to the full spam dataset, seeing how well the PC correlate to the outcome:  
```{r}

typeColor <- ((spam$type=="spam")*1 + 1)
prComp <- prcomp(log10(spam[,-58]+1)) ## often needed in PCA to deal with extreme skew in the data
plot(prComp$x[,1], prComp$x[,2], col=typeColor, xlab="PC1", ylab="PC2")

```
  
PCA can also be run inside the caret function, making use of preProcess:  
```{r}

## pcaComp is the number of components to create
## log10 is used to solve for the problem of extreme skew in the underlying data
preProc <- preProcess(log10(spam[,-58]+1), method="pca", pcaComp=2)
spamPC <- predict(preProc, log10(spam[,-58]+1))
plot(spamPC[,1], spamPC[,2], col=typeColor)

```

Lastly, the full process can be used to train the model and then test it.  Note that preProcess ensures that we use the same parameters on the test data.  It is over-fitting if we update PCA to use new transformations based on what could be observed in the test data.  We should be going in to this blind.  
  
```{r}

## Create PCA from the training data, use methodology on training data, fit GLM
preProc <- preProcess(log10(training[,-58]+1), method="pca", pcaComp=2)
trainPC <- predict(preProc, log10(training[,-58]+1))
modelFit <- train(training$type ~ ., method="glm", data=trainPC)

## Use identical methodology on testing data, and review the accuracy
testPC <- predict(preProc, log10(testing[,-58]+1))
confusionMatrix(predict(modelFit, testPC), testing$type)

```
  
This process alone, using just two principal components, is ~89% accurate in classifying e-mail as spam.  This significantly improves on the no-information rate of ~61%.  
  
Lastly, the PCA approach can be passed directly to the train() function, which will create the same number of PCA as predictors in the initial data.  This drives accuracy up slightly more to ~92%:  
```{r, cache=TRUE}

## Set cache=TRUE to speed up the re-run
modelFit <- train(training$type ~ ., method="glm", preProcess="pca", data=training)
confusionMatrix(predict(modelFit, testing), testing$type)

```
  
A few final thoughts on PCA include:  
  
* It tends to be most useful for linear models such as LDA (linear discriminant)  
* It will likely make it harder to interpret the predictors  
* Watch out for outliers, which are especially bad for PCA!  Plot to identify, transform (log, Box-Cox, etc.) as needed prior to PCA  
* Additional details are in "Exploratory Data Analysis" (JHU Coursera) and "Elements of Statistical Learning"  
  
####_Predicting with regression_  
The caret library works well with regression, layering on top some of the machine-learning components (ease of test/train, predictions, etc.).  The advantage of regression is its simplicity (implement and interpret) and accuracy in linear settings.  The disadvantage of regression is that it typically shows poor performance in decidedly non-linear setting.  
  
The Old Faithful eruptions data (datasets "faithful") serves as a background for this example:  
```{r}

library(caret); data(faithful); set.seed(333)
inTrain <- createDataPartition(y=faithful$waiting, p=0.5, list=FALSE)
trainFaith <- faithful[inTrain, ]; testFaith <- faithful[-inTrain, ]
head(trainFaith)

## Data are largely linear - fit an LM accordingly
plot(trainFaith$waiting, trainFaith$eruptions, pch=19, col="blue", xlab="Waiting", ylab="Duration")
lm1 <- lm(eruptions ~ waiting, data=trainFaith)
summary(lm1)
lines(trainFaith$waiting, lm1$fitted, lwd=3)

```

Given the linearity of the relationship, the typical lm() approach from previous modules would likely work fine.  See for example:  
```{r}

## Predict forward on to some new data
## Base R/Stats commands
coef(lm1)[[1]] + coef(lm1)[[2]]*80

## Predict function
newdata <- data.frame(waiting=80)
predict(lm1, newdata)

```
  
The error rates can be compared on the test and training data.  The test data gives a more realistic estimate for the "out of sample" (true) error, since it is not at all influenced (at least not favorably!) by any overfitting to noise in the training data.  
```{r}

par(mfrow=c(1,2))

## Apply to training data
plot(trainFaith$waiting, trainFaith$eruptions, pch=19, col="blue", xlab="Waiting", ylab="Duration")
lines(trainFaith$waiting, predict(lm1), lwd=3)

## Apply to testing data
plot(testFaith$waiting, testFaith$eruptions, pch=19, col="blue", xlab="Waiting", ylab="Duration")
lines(testFaith$waiting, predict(lm1, newdata=testFaith), lwd=3)

## Compare RMSE
sqrt(mean((lm1$fitted - trainFaith$eruptions)^2))
sqrt(mean((predict(lm1, newdata=testFaith) - testFaith$eruptions)^2))

par(mfrow=c(1,1))

## Plot the prediction intervals as well
pred1 <- predict(lm1, newdata=testFaith, interval="prediction")
ord <- order(testFaith$waiting)
plot(testFaith$waiting, testFaith$eruptions, pch=19, col="blue")
matlines(testFaith$waiting[ord], pred1[ord, ], type="l", col=c(1,2,2), lty=c(1,1,1), lwd=3)

```
  
The identical model can be achieved using the train() function in the caret library:  
```{r}
modFit <- train(eruptions ~ waiting, data=trainFaith, method="lm")
summary(modFit$finalModel)

```

In summary, the caret library can be a useful aid to linear regression.  Sometimes, the many advantages of regression make this an optimal predictive approach.  Other times, the much higher predictive power of other approaches (especially when data are non-linear) pushes regression in to the background.  
  
####_Predicting with regression (multiple covariates)_  
This topic serves as a mix of using multiple covariates and exploring which are important.  This portion will focus on the ISLR "Wage" dataset.  The standard approach is run to create test/training data, followed by some exploratory plotting.  
  
```{r}
library(ISLR); library(ggplot2); library(caret)
data(Wage); Wage <- subset(Wage, select=-c(logwage)) ## we are going to predict logwage in this case
summary(Wage)

inTrain <- createDataPartition(y=Wage$wage, p=0.7, list=FALSE)
training <- Wage[inTrain, ] ; testing <- Wage[-inTrain, ]
dim(training) ; dim(testing)

featurePlot(x=training[ , c("age", "education", "jobclass")], y=training$wage, plot="pairs")
qplot(age, wage, data=training)
qplot(age, wage, data=training, color=jobclass)
qplot(age, wage, data=training, color=education)

```
  
The train() command can be used to fit an LM.  The defaults are 25 reps of bootstrapping for error estimation.  
```{r}
modFit <- train(wage ~ age + jobclass + education, method="lm", data=training)
finMod <- modFit$finalModel
print(modFit)

```
  
And, diagnostics plots can be valuable also:  
```{r}
## Plot the residuals
plot(finMod, 1, pch=19, cex=0.5, col="#00000010")

## Shade by race (possible confounder not included in original LM)
qplot(finMod$fitted, finMod$residuals, color=race, data=training)

## Check for any patterns in residuals by index (missing variable)
plot(finMod$residuals, pch=19)

## Apply to the testing data and see how the model has performed
pred <- predict(modFit, testing)
qplot(wage, pred, color=year, data=testing)
```
  
Alternately, the models could be called for all of the covariates:  
```{r}
modFitAll <- train(wage ~ ., data=training, method="lm")
print(modFitAll)
pred <- predict(modFitAll, testing)
qplot(wage, pred, data=testing)
```

So, the train() function takes multivariate regression and 1) simplifies the test/train process, while 2) better estimating error rates by using bootstrapping over multiple samples.  
  
####_Predicting with trees_  
The key idea for prediction with trees include:  
  
* Iteratively split the data in groups  
* Evaluate homogeneity within groups  
* Split again when necessary  
* PROS: Easy to interpret, good with non-linearity  
* CONS: Over-fitting (especially if no cross-fit or pruning), variable results, hard to estimate uncertainty  
  
The basic algorithm runs as follows:  
  
* Start with all variable in a single group  
* Find the variable/split that best separates the groups  
* Divide the data in two groups ("leaves") on that split ("node")  
* Within each split, find the best variable/split for separating the outcomes  
* Continue until the groups are either too small or sufficiently pure  
  
Measures of impurity include:  
  
* Misclassification: average percentage of "minority outcome" (0=perfect purity, 0.5=random)  
* Gini: 1 - probability^2 (0=perfect purity, 0.5=random)  
* Deviance/information-gain: -(sum-of p*log2(p)) where 0=perfect purity and 1=no purity  
* Wikipedia defines Gini as the probability that an element would be wrongly labeled if it were assigned at random in proportion to the group; so 60-40 would be 0.6 * 0.4 + 0.4 * 0.6 = .48  
  
The iris data can be handy for an example:  
```{r, cache=TRUE}
data(iris); library(caret); library(ggplot2); names(iris)
table(iris$Species)

## Create the test and train data
inTrain <- createDataPartition(y=iris$Species, p=0.7, list=FALSE)
training <- iris[inTrain, ]
testing <- iris[-inTrain, ]
dim(training); dim(testing)

## Exploratory plotting
qplot(Petal.Width, Sepal.Width, color=Species, data=training)

## Tree-based modeling (rpart)
modFit <- train(Species ~ ., method="rpart", data=training)
print(modFit$finalModel)

## Ugly plots
plot(modFit$finalModel, uniform=TRUE, main="Classification Tree")
text(modFit$finalModel, use.n=TRUE, all=TRUE, cex=0.8)

## Prettier plots
library(rattle)
fancyRpartPlot(modFit$finalModel)

## Predictions
predict(modFit, newdata=testing)

```
  
Classification trees are non-linear models in which all monotonic transforms will produce the same outcome.  They are especially good for finding interactions among variables.  In addition to "rpart" within caret, R has libraries for "party" and "tree".  
  
####_Bagging_  
The phrase "bagging" is short for "bootstrap aggregating".  Blending models can often smooth out the biases and variances of the individual modeling fits.  
  
The basic idea of bagging is to follow a three-step process:  
  
1.  Resample cases and recalculate predictions  
2.  Take the average or majority vote  
3.  Expect similar biase but reduced variance; especially useful for non-linear models  
  
For an example, we can use the "ozone" dataset from the library ElemStatLearn:  
```{r}
library(ElemStatLearn); 
data(ozone, package="ElemStatLearn")
ozone <- ozone[order(ozone$ozone), ]
head(ozone)

## Example for bagged trees
## Empty matrix for storing estimates for 1:155 on models run 10 times
ll <- matrix(NA, nrow=10, ncol=155)	

## Run the process 10 times
for (intCtr in 1:10) {	
	## Sample with replacement from the original dataset (bootstrap resampling)
    ss <- sample(1:dim(ozone)[1], replace=TRUE)
    ## Create and sort the dataset (there will be duplicates in it due to bootstrapping)
	ozone0 <- ozone[ss, ] ; ozone0 <- ozone0[order(ozone0$ozone), ]
	## smoothed curve, very similar to spline
	loess0 <- loess(temperature ~ ozone, data=ozone0, span=0.2)
	## Apply the loess to make predictions for 1:155, and store these in the ll matrix
	ll[intCtr, ] <- predict(loess0, newdata=data.frame(ozone=1:155))
}	

## Graph the actual relationship, the individual predictions, and the aggregated (mean) predictions
plot(ozone$ozone, ozone$temperature, pch=19, cex=0.5)
for (intCtr in 1:10) { lines(1:155, ll[intCtr, ], col="grey", lwd=2) }
lines(1:155, apply(ll,2,FUN=mean), col="red", lwd=2)

```
  
The red (mean) line still shows some structural artifacts, but it has lower variance and similar bias to any of the individual grey fits (which are all badly over-fit).  

Alternately, the caret library can be used to perform bagging.  Using the method= you have access to bagEarth, treebag, and bagFDA.  Alternately, you can bag any model using the bag() function.  

The example below is somewhat advanced, and care is suggested with any customization prior to further study.  After running the model, a few functions are printed for reference as well:  
```{r}
predictors <- data.frame(ozone=ozone$ozone)
temperature <- ozone$temperature
treeBag <- bag(predictors, temperature, B=10, 
               bagControl=bagControl(fit=ctreeBag$fit, predict=ctreeBag$pred, 
                                     aggregate=ctreeBag$aggregate
                                     )
               )

## Plot the data, one of the individual fits, and the blended fit
plot(ozone$ozone, temperature, col="lightgrey", pch=19)
points(ozone$ozone, predict(treeBag$fits[[1]]$fit, predictors), pch=19, col="red")
points(ozone$ozone, predict(treeBag, predictors), pch=19, col="blue")

## Print the key functions
print(ctreeBag$fit)
print(ctreeBag$pred)
print(ctreeBag$aggregate)

```
  
This is most useful for non-linear models, and particularly useful with trees (see below for random forest).  
  
####_Random Forests_  
Random forests are in many ways an extension of bagging.  They are often one of the winning techniques (along with boosting) in prediction contests.  The general process includes:  
  
1.  Bootstrap the samples (grow trees for each of the sub-samples)  
2.  At each split, bootstrap the variables (allow different variables to be considered)  
3.  Grow multiple trees and vote (run each new observation through all the trees, then vote/average)  
  
PROS: Especially good for accuracy  
CONS: Speed, Interpretation, Overfitting  
  
The iris data can serve as an example of the process:  
```{r}
data(iris); library(ggplot2); library(caret)
inTrain <- createDataPartition(y=iris$Species, p=0.7, list=FALSE)
training <- iris[inTrain, ]
testing <- iris[-inTrain, ]

## Run the model - prox=TRUE provides some extra helpful data
modFit <- train(Species ~ ., data=training, method="rf", prox=TRUE) 

## Print descriptive model statistics
modFit

## Review tree #2 (k determines the tree)
getTree(modFit$finalModel, k=2, labelVar=TRUE)

## Review the location of the centers -- requires the prox=TRUE from train() as per above
irisP <- classCenter(training[, c(3,4)], training$Species, modFit$finalModel$prox)
irisP <- as.data.frame(irisP)
irisP$Species <- rownames(irisP)

## Plot the relevant data and centers
p <- qplot(Petal.Width, Petal.Length, col=Species, data=training)
p + geom_point(aes(x=Petal.Width, y=Petal.Length, col=Species), size=5, shape=4, data=irisP)

## Predict new values
pred <- predict(modFit, testing); testing$predRight <- pred==testing$Species
table(pred, testing$Species)
qplot(Petal.Width, Petal.Length, color=predRight, data=testing, main="newdata Predictions")
```
  
Random forests are often both very accurate and very difficult to interpret.  The goal is to push accuracy at the expense of parsimony.  There is some risk of overfitting - see rfcv().  
  
####_Boosting_  
Boosting is often one of the top predictive techniques.  The basic ideas are to:  
  
1.  Take many (potentially weak) indicators  
2.  Weight them and add them up  
3.  Get a stronger predictor  
  
In slightly more detail, the approach is:  
  
1.  Start with a set of classifiers h1 . . . hk, often of the same class (e.g., many trees, many regressions, etc.)  
2.  Create a combined classifier that is sum-over-i-of alpha(i) * h(i), where alpha(i) need not sum to 1  
  * Goal is to minimize error on the training set  
  * Iterative process, select one h(i) at each step  
  * Calculate weights based on errors  
  * Upweight for the missed classifications, and select the next h(i)  
3.  The most famous algorithm is probably "adaboost"  
  
Boosting in R can be done with any subset of classifiers:  
  
* One large sub-class is "gradient boosting"  
* R has multiple boosting libraries -- gbm (trees), mboost (model-based), ada (additive logistic), gamBoost (general additive), etc.  
* Most of these are available in the caret package  
  
An example can be taken from the ISLR "wages" data:  
```{r, cache=TRUE}
## Set cache=TRUE, the gbm takes a while to run in the repeats
library(ISLR); library(ggplot2); library(caret)
data(Wage)
Wage <- subset(Wage, select=-c(logwage)) ## too good of a predictor!
Wage <- subset(Wage, select=-c(sex, region)) ## no variance, throws tons of warnings

## Create the test and train data
inTrain <- createDataPartition(y=Wage$wage, p=0.7, list=FALSE)
training <- Wage[inTrain, ]
testing <- Wage[-inTrain, ]

## gbm is boosting with trees, gives a lot of info if not using verbose=FALSE
modFit <- train(wage ~ ., method="gbm", data=training, verbose=FALSE) 
print(modFit)

## Plot the predictions
qplot(predict(modFit, testing), wage, data=testing)

```
  
Typically, boosting and random forests are the techniques that win prediction contests.  
  
####_Model Based Prediction_  
The basic idea of model-based prediction is to assume the data follow a probabilistic model and to use Bayes' theorem to identify optimal classifiers.  
  
* PROS: Takes advantage of data structures, computationally convenient, reasonably accurate on real-world problems  
* CONS: Requires additional assumptions about the data, reduced accuracy if assuming an inaccurate model  
  
The expansion on the general idea is as follows:  
  
1.  Build a parametric model for the conitional distribution P(Y=k | X=x)  
2.  Typical approach goes back to Bayes' theorem -- leverage priors vs. likelihood of observed outcomes  
3.  Typically, the prior probabilities are set in advance  
4.  A common choice is the Gaussian  
5.  Classification is made based on the highest value of P(Y=k | X=x)  
  
Many linear models take advantage of this - see "Elements of Statistical Learning" for example:  
  
* Linear discriminant analysis (LDA) assumes f(k)(x) is multivariate Gaussian with the same covariances  
* Quadratic discriminant analysis assumes f(k)(x) is multivariate Gaussian with different covariances  
* Model-based prediction assumes more complicated versions of the covariance matrix  
* Naive Bayes assumes independence between features for model-building  
  
The basic idea behind LDA is that probabilities become more likely one way or the other on either side of a given line (there can be multiple lines carving out multiple spaces of "greatest probability").  The discriminant function is associated with "maximum likelihood".  
  
Naive Bayes is an attempt to simplify the problem a bit.  If the goal is to estimate P(Y=k | X1, X2, . . . , Xm) then we assume this probability is proportional to P(X1, X2, . . . ,Xm | Y=k).  This is especially good in binary or categorical situations, for example test classification.  
  
While this module was not very well explained, below is an example from the iris data:  
```{r}
data(iris); library(ggplot2); names(iris)
table(iris$Species)

inTrain <- createDataPartition(y=iris$Species, p=0.7, list=FALSE)
training <- iris[inTrain, ]
testing <- iris[-inTrain, ]
dim(training); dim(testing)

## Plot the locations
qplot(Petal.Width, Sepal.Width, color=Species, data=training)

## Run (and then predict) an LDA and a Naive Bayes
modlda <- train(Species ~ ., data=training, method="lda")
modnb <- train(Species ~ ., data=training, method="nb")
plda <- predict(modlda, testing)
pnb <- predict(modnb, testing)

## Note how Naïve Bayes (nb) gives an almost identical result here
table(plda, pnb) 

## Plot them out, with different colors depending on where the predictions agree
qplot(Petal.Width, Sepal.Width, color=(plda==pnb), data=testing)
```
  
Supposedly, there is a much more detailed explanation available in "Elements of Statistical Learning".  
  
####_Regularized Regression_  
The basic idea of regularized regression is to fit a regression and then penalize large coefficients.  
  
PROS: Helps with bias/variance (prediction error), helps with model selection  
CONS: Computationally demanding, does not perform as well as random forests and boosting  
  
Suppose you have Y = Beta0 + Beta1 * X1 + Beta2 * X2 + epsilon:  
  
* Suppose that X1 and X2 are nearly collinear  
* The model could instead be approximated by Y = Beta0 + (Beta1 + Beta2) * X2 + epsilon.  This will (slightly) increase the bias in estimating Y (a predictor is left out), but with the benefit of greatly reduced variance (since you no longer have jumbo Beta1 and Beta2 with opposite signs).  The result can actually be improved estimates and/or predictions for Y, since Overall Error is Irreducible Error (natural random spread of Y) + Bias^2 (not having the perfect mean) + Variance (having a large prediction spread around the perfect mean).  
  
An example can be drawn from the prostate cancer dataset:  
  
```{r}
library(ElemStatLearn); data(prostate); str(prostate)
round(cor(prostate),2)

inTrain <- createDataPartition(y=prostate$train, p=0.75, list=FALSE)
testProstate <- prostate[-inTrain, ]
trainProstate <- prostate[inTrain, ]

## Run a straight-up GLM
glmProstate <- train(as.factor(train) ~ ., data=trainProstate, method="glm")
print(glmProstate)
glmProstate$finalModel

## Use it to make predictions (they are horrible!)
predTest <- predict(glmProstate, testProstate)
confusionMatrix(predTest, testProstate$train)
```
  
A very common pattern for prediction errors is the following:  
  
* Error in the training set will always decrease with more predictors (can train on noise)  
* Error in the test set will decrease with more predictors, then hit a global minimum, then increase with more predictors as it is besieged by overfitting of the training set  
* The same general pattern holds for any model complexity -- there is a global minimum error at a certain complexity, with error increasing as the model becomes either less complex or more complex than that  
  
Splitting samples is typically the best approach - "there is no better method when data and computation time allow for it".  
  
* Divide data in to train, test, and validation  
* Treat validation set as test data, train all competing models on train data, pick best on validation  
* Can then still assess the error rate on the test data (validation data is compormised by having been used in the choice of training models)  
* Option to re-split and repeat the steps described above for a better estimate of the error rate  
* Common problems include 1) lack of data, and 2) lack of computational time  
  
As a reminder about overall error, suppose that you decompose the components:  
  
* Y(i) = f(X(i)) + eps(i)  
* E[ { Y - f(h)(X) }^2 ] = sigma^2 + Bias^2 + Variance  
* Total Error = Irreducible Error + Bias^2 + Variance (technically Error^2)  
* The goal is to reduce Total Error - nothing you can do about Irreducible Error, but you have options for trading off Bias^2 and Variance  
  
Regularization for regression builds off the idea of Bias/Variance trade-off:  
  
* If every Beta is unconstrained, then they can explode (and thus be highly susceptible to huge variance)  
* The main thrust is to add a "penalized" sum-square error  
* Common objectives for the penalty are to 1) reduce complexity, 2) reduce variance, and 3) respect the structure of the problem  
  
One example is "ridge regression", which penalizes by lamba * sum-over-i-of Beta(i)^2
  
* RSS now becomes RSS + penalty, meaning that large Beta are disfavored  
* The regression can be non-singular even if t(X) %*% X is singular  
* As you increase lamba, all coefficients become closer to zero (Beta(i) -> 0 as lambda -> oo)  
  
Lambda can be thought of as the tuning parameter for the ridge regression:  
  
* Controls the size of the coefficients  
* Controls the amount of "regularization"  
* As lambda -> 0 you get regular least-squares  
* As lambda -> oo you get all Beta=0  
* Cross-validation can help pick the best lambda for trading off Bias and Variance  
  
Lasso is a similar ideas, though implemented instead with the hard constraint that sum(abs(Beta)) <= s.  Available methods in R include ridge, lasso, and relaxo.  
  
Hector Corrado Bravo writes in more detail about this topic in "Practical Machine Learning".  
  
####_Combining Predictors_  
The key ideas behind combining predictors include:  
  
* Combine classifiers through averaging and/or voting and/or etc.  
* PROS: Improves accuracy  
* CONS: Reduces interpretablity  
* Boosting, bagging, and random forests are variants on this theme  
  
One example is the winner of the Netflix prize - they combined 107 predictors, each of which was a machine learning algorithm.  
  
The basic intuition is in the power of the majority vote (multi-game series).  Suppose each of your independent predictors has a 70% probability of correctly classifying a 2-factor (e.g., TRUE/FALSE) decision:  
  
* If you have only 1 predictor, you will be 70% accurate  
* If you majority vote on 5 predictors, you will be 84% accurate  
* If you majority vote on 101 predictors, you will be 99.9% accurate  
  
There are two approaches for combining classifiers:  
  
* Similar Classifiers - bagging, boosting, random forests  
* Different Classifiers - stacking, ensembling  
  
Another example using the ISLR wage data:  
```{r, cache=TRUE}
library(ISLR); data(Wage); library(ggplot2); library(caret)

## Remove logWage as it is too good of a predictor for wage!
Wage <- subset(Wage, select=-c(logwage))

## Create an analysis (building) and validation dataset
inBuild <- createDataPartition(y=Wage$wage, p=0.7, list=FALSE)
validation <- Wage[-inBuild, ]
building <- Wage[inBuild, ]

## Split the analysis (building) dataset in to test and train
inTrain <- createDataPartition(y=building$wage, p=0.7, list=FALSE)
testing <- building[-inTrain, ]
training <- building[inTrain, ]

dim(training); dim(testing); dim(validation)

## Run a GLM and a Random Forest, and use each to predict the testing data
mod1 <- train(wage ~ ., method="glm", data=training)
mod2 <- train(wage ~ ., method="rf", data=training, trControl=trainControl(method="cv"), number=3)
pred1 <- predict(mod1, testing)
pred2 <- predict(mod2, testing)
qplot(pred1, pred2, color=wage, data=testing)

## Now, build a model that combines the predictors (GAM or general additive modelb)
predDF <- data.frame(pred1, pred2, wage=testing$wage)
combModFit <- train(wage ~ ., method="gam", data=predDF)
combPred <- predict(combModFit, predDF)

## Compare the errors - lowest for the combined model
sqrt(mean((pred1 - testing$wage)^2))
sqrt(mean((pred2 - testing$wage)^2))
sqrt(mean((combPred - testing$wage)^2))

## The test set is compromised by having been used to blend the models; check on validation data
pred1V <- predict(mod1, validation)
pred2V <- predict(mod2, validation)
predVDF <- data.frame(pred1=pred1V, pred2=pred2V)
combPredV <- predict(combModFit, predVDF)

## Compare the errors
sqrt(mean((pred1V - validation$wage)^2))
sqrt(mean((pred2V - validation$wage)^2))
sqrt(mean((combPredV - validation$wage)^2))

```
  
The above may not be the best example, but it makes the idea clear.  Even simple blending can be a valuable technique for improving accuracy:  
  
* For classification, build an odd number of models, use each to predict, and take the majority vote  
* For continuous prediction, take the models and combine through GAM or averaging or the like  
  
As a caution, the winning model from the Netflix prize was never implemented!  It was too complicated and computationally expensive.  It is important to consider factors other than maximizing prediction.  
  
####_Forecasting_  
Time series data (e.g., GOOG from NASDAQ) intoduces some additional data dependencies (structures) which require different analysis techniques.  In short, Y(n+1) and Y(n) can no longer both be considered iid from the same population, and it is likely that Y(n+1) will be dependent on Y(n).  
  
Some common issues include:  
  
* Data are dependent over time  
* Specific patterns may be observed - trends, seasonal, cyclical  
* Sub-sampling in to test and train may be more challenging  
* Spatial data can show similar challenges (near neighbors being dependent on each other)  
* Typically, the objective is to predict one or more observations in to the future  
* All standard predictive techniques can technically be used (but with caution!)  
  
Spurious correlations are very common:  
  
* Google stock price vs. Network Solitaire  
* Population maps being used to make business decisions about correlations  
* <http://xkcd.com> for additional examples  
  
Extrapolation can also cause big problems unless there is an asymptote.  Eventually, the mile will be run in negative time!  
  
The quantmod library is helpful for extracting stock prices and can be leveraged for this example:  
```{r}
library(quantmod)

## Grab the Google stock prices from 2008-2013 from Yahoo
from.dat <- as.Date("01/01/08", format="%m/%d/%y")
to.dat <- as.Date("12/31/13", format="%m/%d/%y")
getSymbols("GOOG", src="yahoo", from=from.dat, to=to.dat)
head(GOOG)

## Plot the monthly Google stock price
mGoog <- to.monthly(GOOG)
googOpen <- Op(mGoog)
ts1 <- ts(googOpen, frequency=12)
plot(ts1, xlab="Years + 1", ylab="GOOG")

## Plot the decomposition - overall, trend, seasonal, cyclical (random)
plot(decompose(ts1), xlab="Years + 1")
```
  
There are then several techniques that can be run to generate the forecasts:  
```{r}
ts1Train <- window(ts1, start=1, end=5)
ts1Test <- window(ts1, start=5, end=(7-0.01))
ts1Train

## Simple moving averages
plot(ts1Train); library(forecast) ## The "forecast" package has the ma() function
lines(ma(ts1Train, order=3), col="red")

## Exponential smoothing
ets1 <- ets(ts1Train, model="MMM")
fcast <- forecast(ets1)
plot(fcast)
lines(ts1Test, col="red")

## Accuracy tests
accuracy(fcast, ts1Test)

```
  
There is an entire field devoted to this space.  A good resource is Rob Hyndman's "Forecasting: Principles and Practice".  The quantmod and quandl packages are especially useful as well.  
  
####_Unsupervised Prediction_  
The key concept of unsupervised prediction is that you sometimes do not know the labels of what you are trying to predict:  
  
* To bulit a predictor, you create clusters, name clusters, and build predictors for clusters  
* Then, you use the predictor in a new dataset to predict the clusters  
  
Suppose, for example, that you have the iris data but minus the Species field:  
```{r}
data(iris); 
library(ggplot2)

inTrain <- createDataPartition(y=iris$Species, p=0.7, list=FALSE)
training <- iris[inTrain, ]
testing <- iris[-inTrain, ]
dim(training); dim(testing)

## Create three clusters using k-means on the training data
kMeans1 <- kmeans(subset(training, select=-c(Species)), centers=3)
training$clusters <- as.factor(kMeans1$cluster)
qplot(Petal.Width, Petal.Length, color=clusters, data=training)

## Just as an FYI, see how good they match to the "real" clusters (Species)
table(kMeans1$cluster, training$Species) ## you would not actually know these

## Model the training data against the clusters
modFit <- train(clusters ~ ., data=subset(training, select=-c(Species)), method="rpart")
table(predict(modFit, training), training$Species)

## Apply it to the test data
testClusterPred <- predict(modFit, testing)
table(testClusterPred, testing$Species) ## Mix of errors as per above

```
  
There are two causes of the test set error rate; first, uncertainty (error) in the rpart modelling, and second, uncertainty (error) in the k-means approximation to the actual species.  

A few final notes include:  
  
1.  The cl_predict function in package "clue" has much of the same functionality, though it is frequently better to create your own  
2.  Be wary of over-interpretation; this method at its core is just a form of Exploratory Data Analysis  
3.  This is also the basic approach behind recommendation engines; cluster people, then see what interests they have in common  
  
## Wrap-Up and Next Steps  
The caret capabilities are extremely useful and flexible.  Broadly, the key steps include:  
  
* Split the data in to test, train, and validate (if wanting to use test to help tune train) - basic function is createDataPartition()  
* Run exploratory data analysis on the training data  
* Modify any predictors as needed (PCA, normalize, combine, cluster, etc.) and be sure that the same commands can be run on the test/validation data - basic function is preProcess()  
* Run one or more models, ideally including a method of cross-validation (k-fold, bootstrap, etc.) - basic function is train(), with trainControl() containing the tuning parameters  
* Be careful that the default tuning grid is often not so good - mtry (randomForest) and cp/minsplit (rpart) in particular can often be significantly optimized with a smarter search  
* Check how well the model built on training data performs on training data, using a mix of model outputs, predict(), confusionMatrix(), and RMSE by hand calculations  
* Optionally, if you have created 3+ partitions, use one of the other partitions to help with model tuning and/or model blending and/or model selection  
* Select a final model, then run it a single time on a hold-out dataset that has not been touched in the process - basic functions include predict() followed by confusionMatrix() or RMSE by hand  
* This holdout prediction provides a decent estimate for out-of-sample error (though the prediction methodology will only be valid for data that is iid from the same population as created the original data set, so be cautious of artifacts that may solely be in the current dataset - timestamp, Index, etc.)  
  
